---
title: Building benjeffrey.com with Hakyll
description: How I build and deploy my website using Hakyll, the static-site generator written in Haskell.
tags: web-development
date: 2013-04-24
---

A few weeks ago I finally bought the [benjeffrey.com][] domain name,
which I've now moved to as my main presence on the
<abbr title="World Wide Web">WWW</abbr>. So change your bookmarks
and update your contacts, because [this is
my new home][benjeffrey.com][^email]!

After all, [benjeffrey.net][] was the first webpage I'd ever really put
online (back when I was paying Â£10/year for [a domain name and shared
hosting][fasthostingdirect]) and now my web presence was looking
rather... meh. Certainly not the standard you'd expect from a student of
<abbr title="Computer Science">Informatics</abbr>!


I wanted the following for my new web setup:

* a static-site generator to build the content, because ~~that's what
    all the cool kids are doing~~ I liked the idea of my website
    being portable
* a sensible way to deploy my website, whether that meant using
    a Git-based worklow, or simply `rsync`ing it (as I ended up doing)
* the ability to write posts in [Pandoc Markdown][pandoc md] with all its
    fancy extensions; it supports LaTex expressions, as well as tables
    and footnotes, making fully-featured complex documents in Markdown
    a whole lot easier.

I came across a cool little project by the name of [Hakyll][], while
browsing the [Pandoc wiki][] looking for better content templates.

Hakyll performs much the same function as [Jekyll][] and [similar static
site generators][inspirations]. The primary difference between Hakyll and
other software is that Hakyll is written in the functional programming
language [Haskell][]. I wanted to ease this beautiful language in to my
regular programming, since we spent the entire first semester learning it
while getting to grips with Functional Programming, here at the
University of Edinburgh.


Customising Hakyll
------------------

### Basic setup

**Requirements:** GHC and [Cabal][], Haskell's package-management system.

You should install Hakyll on your system through Cabal, so it can pull in
its (many) dependencies, and then install the default Hakyll script into
your (empty) website directory with `hakyll-init`[^cabal-scripts]:

```bash
cabal install hakyll
hakyll-init {directory}
cd {directory}
git init
```

My `.gitignore` file includes the following lines (alongside
[GitHub's Haskell defaults][haskell-gi]) so as not to commit the files
generated by Hakyll:

```bash
# Hakyll compiled site
_cache
_site
site
hakyll
```

Next thing, I give script has a more descriptive name:

```bash
mv site.hs hakyll.hs
```

One of the most interesting things about the Hakyll package is that it
can be used more as a *library* of helpful functions, than a program per
se. The Hakyll *script* installed in the directory by `hakyll-init` is a
regular old Haskell source file which imports the Hakyll package and
chains together various functions to describe [an I/O Action][hakyll
main] which builds the static site! To generate the static site HTML,
just compile the Haskell source and run the resulting executable's
`build` command:

```bash
ghc --make hakyll.hs
./hakyll build
```

[Hakyll's tutorials][hakyll-cmds] explain the various commands that the `hakyll`
executable now provides.

The following sections describe the various pieces of functionality in
[my hakyll.hs][hakyll-source] which aren't included by
default.

### Site Icon

My site icon lives at `images/favicon.ico` before compilation. The
following Hakyll rule copies it to `favicon.ico` in the compiled site
directory:

```haskell
main :: IO ()
main = hakyll $ do
    -- ...

    -- copy site icon to `favicon.ico`
    match "images/favicon.ico" $ do
            route   (constRoute "favicon.ico")
            compile copyFileCompiler
    -- ...
```

As well as moving the ICO file, I also added

```html
<head>
    <!-- ... -->
    <link rel="shortcut icon" href="/favicon.ico" />
    <!-- ... -->
</head>
```

into the [default template][]'s `head` element, just in case. To be
honest, this really makes the Hakyll rule redundant, as I could set the
`href` attribute to anything. But where'd be the fun in that?


### Copying Documents to the Web Root

The following rule just ensures that the site [`robots.txt`](/robots.txt)
and [`humans.txt`](/humans.txt) get copied into the web root (i.e. `/`):

```haskell
-- copy humans.txt and robots.txt to web root
match (fromList ["humans.txt", "robots.txt"]) $ do
    route   idRoute
    compile copyFileCompiler
```


### Compiling Documents to the Web Root with Pandoc

I used to keep the location of my CV short by writing it as a raw HTML
file, and keeping it in the document root of the webserver as `/cv`,
stripping the file suffix. This required some Apache `.htaccess` rules
for it to actually serve the file with the correct content-type, but it
worked. But, as you can imagine, updating HTML by hand got pretty tiring,
so I now write my CV as a Markdown file.

So that my CV still lives at [/cv](/cv), I wrote a custom rule that
places documents in the web root, after they've been compiled through
Pandoc.

The default Hakyll script has a rule for copying static files into the
generated web root. I used the same rule, only replacing the
`copyFileCompiler` with the `pandocCompiler`, then setting it to run
through the necessary templates:

```haskell
-- Compile static pages to web root with Pandoc
match (fromList ["cv.md"]) $ do
    route   $ setExtension ""
    compile $ pandocCompiler
        >>= loadAndApplyTemplate "templates/default.html" defaultContext
        >>= relativizeUrls
```


### Compiling Sass/SCSS through Hakyll

**Requirements:** [Sass][] and [Compass][] gems (installed systemwide).

I decided to use Zurb's [Foundation web framework][foundation] on this
site, as an experiment in "things which aren't Bootstrap". I have a bit
of experience with Sass, and it's quite nice to be able to limit
"div-itis" by using [Foundation's Sass mixin support][foundation-sass]!

[Compass][] is a must for developing Sass stylesheets, collecting
essential functions such as [sticky footers][] in one handy place, and
is required by Foundation anyway.

Luckily, rather than having `compass watch` constantly running when
editing the Sass stylesheets, The Haddock docs for Hakyll [describe a rule
for compiling SCSS to CSS][hakyll-scss] using the `unixFilter`.

This next rule (based on the above) compiles matched the Sass stylesheets
when you issue the Hakyll `build` command, but also tells the `sass`
command to enable Compass and to compress the output:

```haskell
match "scss/app.scss" $do
    route   $ gsubRoute "scss/" (const "css/") `composeRoutes` setExtension "css"
    compile $ getResourceString
        >>= withItemBody (unixFilter "sass" ["-s", "--scss", "--compass", "--style", "compressed"])
        >>= return . fmap compressCss
```

### Removing URL Suffixes

Wherever `setExtension` is used for HTML pages, I've fed it an empty
string, so that webpages don't have the ugly `.html` suffix on the end.

```haskell
match "post/*" $ do
    route $ setExtension ""
    compile $ pandocCompiler
        >>= loadAndApplyTemplate "templates/post.html"    postCtx
        >>= loadAndApplyTemplate "templates/default.html" postCtx
        >>= relativizeUrls
```

Just in case, the templates include the following `meta` tag in the
`head`, to ensure that each page is detected as HTML:

```html
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
```


Deploying with Hakyll
---------------------

Hakyll has a great feature hidden away in its documentation: [the
deployCommand][deploy command]. It turns out that you can specify an
arbitrary command in the configuration for Hakyll to execute when you
run:

```bash
./hakyll deploy
```

One might set this to execute a bash script, but since I just `rsync` the
files up to my server (which is called `parsley` in my SSH config) I've
put the entire command inside my Hakyll Configuration value, at the top
of the script:

```haskell
--------------------------------------------------------------------------------
config :: Configuration
config = defaultConfiguration
        {   deployCommand = "rsync -avz -e ssh ./_site/ parsley:/var/www/benjeffrey.com/"}

--------------------------------------------------------------------------------
```

Hakyll needs to be told to run with your new configuration, so you'll
have to replace the `hakyll :: Rules a -> IO ()` function in the line

```haskell
main = hakyll $ do
```

with the `hakyllWith :: Configuration -> Rules a -> IO ()` function.


Summary
-------

[benjeffrey.com][] is built and deployed (as of
2013-04) through a combination of:

* Hakyll
* Sass & Compass
* Nginx
* Git
* SSH

My final directory structure now looks something like:

```
{directory}
|-- images
    \- ...
|-- posts
    \- ...
|-- scss
   |- app.scss
   |- ...
   |- foundation
       \ ...
|-- templates
     \- ...
|-- archive
|-- config.rb (for Compass)
|-- cv.md
|-- hakyll.hs
|-- hakyll
|-- humans.txt
|-- index.html
|-- nginx
|-- README.md
 \- robots.txt
```

with the whole site [available on GitHub][hakyll-gh].



<!-- footnotes -->

[^email]: My email address will still be <mail@benjeffrey.net> though.
    I'm still figuring out how to best add email to my new domain,
    or even if it's worth adding yet *another* email address to my
    collection! I may look into doing some sort of mail forwarding,
    either at the DNS or the mailbox level, at a later date.

[^cabal-scripts]: If you can't run the `hakyll-init` command, you may
    need to add the local Cabal binary folder to your shell's `$PATH`
    variable with the following lines in your shell config:

    ```bash
    # The following goes into ~/.profile, ~/.zshrc, ~/.bashrc, or similar:

    # Cabal executables
    PATH=$PATH:$HOME/.cabal/bin
    ```


<!-- links -->

[benjeffrey.com]: http://benjeffrey.com
[benjeffrey.net]: http://benjeffrey.net
[fasthostingdirect]: http://www.fasthostingdirect.co.uk/
[Jekyll]: http://jekyllrb.com/
[Octopress]: http://octopress.org/
[GitHub Pages]: http://pages.github.com/
[Hakyll]: http://jaspervdj.be/hakyll/
[Hakyll tutorials]: http://jaspervdj.be/hakyll/tutorials.html
[Hakyll reference]: http://jaspervdj.be/hakyll/reference/index.html
[Bootstrap]: http://twitter.github.io/bootstrap/
[foundation]: http://foundation.zurb.com/
[Cabal]: http://www.haskell.org/cabal/
[INF-YT]: http://inf-yt.org.uk/
[daylerees]: http://daylerees.com/
[ST colour schemes]: https://github.com/daylerees/colour-schemes
[COLOURlovers]: http://www.colourlovers.com/
[Pandoc wiki]: https://github.com/jgm/pandoc/wiki/Pandoc-Extras
[pandoc md]: http://johnmacfarlane.net/pandoc/README.html#pandocs-markdown
[haskell-gi]: https://github.com/github/gitignore/blob/master/Haskell.gitignore
[hakyll-source]: https://github.com/jeffbr13/benjeffrey.com/blob/master/hakyll.hs
[robots]: https://en.wikipedia.org/wiki/Robots_exclusion_standard
[default template]: https://github.com/jeffbr13/benjeffrey.com/blob/master/templates/default.html
[foundation-sass]: http://foundation.zurb.com/docs/sass.html
[sticky footers]: http://compass-style.org/reference/compass/layout/sticky_footer/
[Michael Walker]: http://www.barrucadu.co.uk/
[Citation Needed]: http://citationneeded.me/
[Compass]: http://compass-style.org/
[Sass]: http://sass-lang.com/
[cn-scss]: http://citationneeded.me/hakyll.html#templates-css-static-and-wrapped-files
[hakyll-scss]: http://jaspervdj.be/hakyll/reference/Hakyll-Core-UnixFilter.html
[hakyll-cmds]: http://jaspervdj.be/hakyll/tutorials/02-basics.html
[deploy command]: http://jaspervdj.be/hakyll/reference/Hakyll-Core-Configuration.html#v:deployCommand
[hakyll-gh]: https://github.com/jeffbr13/benjeffrey.com/blob/master/hakyll.hs
[inspirations]: http://jaspervdj.be/hakyll/about.html#inspiration
[Haskell]: http://www.haskell.org/
[hakyll main]: http://jaspervdj.be/hakyll/reference/Hakyll-Main.html#v:hakyll
